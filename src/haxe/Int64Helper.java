// Generated by Haxe 4.0.5
package haxe;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class Int64Helper extends haxe.lang.HxObject
{
	public Int64Helper(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public Int64Helper()
	{
		//line 32 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		haxe.Int64Helper.__hx_ctor_haxe_Int64Helper(this);
	}
	
	
	protected static void __hx_ctor_haxe_Int64Helper(haxe.Int64Helper __hx_this)
	{
	}
	
	
	public static long parseString(java.lang.String sParam)
	{
		//line 37 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		long base = ((long) (10) );
		//line 38 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		long current = ((long) (0) );
		//line 39 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		long multiplier = ((long) (1) );
		//line 40 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		boolean sIsNegative = false;
		//line 42 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		java.lang.String s = ((java.lang.String) (((java.lang.Object) (sParam) )) ).trim();
		//line 43 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		if (haxe.lang.Runtime.valEq(haxe.lang.StringExt.charAt(s, 0), "-")) 
		{
			//line 44 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			sIsNegative = true;
			//line 45 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			s = haxe.lang.StringExt.substring(s, 1, s.length());
		}
		
		//line 47 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		int len = s.length();
		//line 49 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		{
			//line 49 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			int _g = 0;
			//line 49 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			int _g1 = len;
			//line 49 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			while (( _g < _g1 ))
			{
				//line 49 "/home/travis/haxe/std/haxe/Int64Helper.hx"
				int i = _g++;
				//line 50 "/home/travis/haxe/std/haxe/Int64Helper.hx"
				int digitInt = ( ((int) (haxe.lang.Runtime.toInt(haxe.lang.StringExt.charCodeAt(s, ( ( len - 1 ) - i )))) ) - ((int) (48) ) );
				//line 52 "/home/travis/haxe/std/haxe/Int64Helper.hx"
				if (( ( digitInt < 0 ) || ( digitInt > 9 ) )) 
				{
					//line 53 "/home/travis/haxe/std/haxe/Int64Helper.hx"
					throw haxe.lang.HaxeException.wrap("NumberFormatError");
				}
				
				//line 56 "/home/travis/haxe/std/haxe/Int64Helper.hx"
				if (( digitInt != 0 )) 
				{
					//line 57 "/home/travis/haxe/std/haxe/Int64Helper.hx"
					long digit = ((long) (digitInt) );
					//line 58 "/home/travis/haxe/std/haxe/Int64Helper.hx"
					if (sIsNegative) 
					{
						//line 59 "/home/travis/haxe/std/haxe/Int64Helper.hx"
						current = ((long) (( ((long) (current) ) - ((long) (( ((long) (multiplier) ) * ((long) (digit) ) )) ) )) );
						//line 60 "/home/travis/haxe/std/haxe/Int64Helper.hx"
						if ( ! ((haxe.lang.Runtime.toBool(((java.lang.Boolean) (( ((long) (current) ) < 0 )) )))) ) 
						{
							//line 61 "/home/travis/haxe/std/haxe/Int64Helper.hx"
							throw haxe.lang.HaxeException.wrap("NumberFormatError: Underflow");
						}
						
					}
					else
					{
						//line 64 "/home/travis/haxe/std/haxe/Int64Helper.hx"
						current = ((long) (( ((long) (current) ) + ((long) (( ((long) (multiplier) ) * ((long) (digit) ) )) ) )) );
						//line 65 "/home/travis/haxe/std/haxe/Int64Helper.hx"
						if (haxe.lang.Runtime.toBool(((java.lang.Boolean) (( ((long) (current) ) < 0 )) ))) 
						{
							//line 66 "/home/travis/haxe/std/haxe/Int64Helper.hx"
							throw haxe.lang.HaxeException.wrap("NumberFormatError: Overflow");
						}
						
					}
					
				}
				
				//line 71 "/home/travis/haxe/std/haxe/Int64Helper.hx"
				multiplier = ((long) (( ((long) (multiplier) ) * ((long) (base) ) )) );
			}
			
		}
		
		//line 73 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		return current;
	}
	
	
	public static long fromFloat(double f)
	{
		//line 80 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		if (( java.lang.Double.isNaN(f) ||  ! (haxe.lang.Runtime.isFinite(f))  )) 
		{
			//line 81 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			throw haxe.lang.HaxeException.wrap("Number is NaN or Infinite");
		}
		
		//line 84 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		double noFractions = ( f - ( f % 1 ) );
		//line 90 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		if (( noFractions > 9007199254740991.0 )) 
		{
			//line 91 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			throw haxe.lang.HaxeException.wrap("Conversion overflow");
		}
		
		//line 93 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		if (( noFractions < -9007199254740991.0 )) 
		{
			//line 94 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			throw haxe.lang.HaxeException.wrap("Conversion underflow");
		}
		
		//line 97 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		long result = ((long) (0) );
		//line 98 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		boolean neg = ( noFractions < 0 );
		//line 99 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		double rest = ( (neg) ? ( - (noFractions) ) : (noFractions) );
		//line 101 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		int i = 0;
		//line 102 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		while (( rest >= 1 ))
		{
			//line 103 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			double curr = ( rest % 2 );
			//line 104 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			rest /= ((double) (2) );
			//line 105 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			if (( curr >= 1 )) 
			{
				//line 106 "/home/travis/haxe/std/haxe/Int64Helper.hx"
				result = ((long) (( ((long) (result) ) + (((long) (( ((long) (1) ) << i )) )) )) );
			}
			
			//line 108 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			 ++ i;
		}
		
		//line 111 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		if (neg) 
		{
			//line 112 "/home/travis/haxe/std/haxe/Int64Helper.hx"
			result = haxe._Int64.Int64_Impl_.neg(result);
		}
		
		//line 114 "/home/travis/haxe/std/haxe/Int64Helper.hx"
		return result;
	}
	
	
}


