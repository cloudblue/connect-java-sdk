// Generated by Haxe 4.0.5
package haxe.crypto;

import haxe.root.*;

@SuppressWarnings(value={"rawtypes", "unchecked"})
public class Base64 extends haxe.lang.HxObject
{
	static
	{
		//line 29 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		haxe.crypto.Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
		//line 30 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		haxe.crypto.Base64.BYTES = haxe.io.Bytes.ofString(haxe.crypto.Base64.CHARS, null);
		//line 32 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		haxe.crypto.Base64.URL_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
		//line 33 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		haxe.crypto.Base64.URL_BYTES = haxe.io.Bytes.ofString(haxe.crypto.Base64.URL_CHARS, null);
	}
	
	public Base64(haxe.lang.EmptyObject empty)
	{
	}
	
	
	public Base64()
	{
		//line 28 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		haxe.crypto.Base64.__hx_ctor_haxe_crypto_Base64(this);
	}
	
	
	protected static void __hx_ctor_haxe_crypto_Base64(haxe.crypto.Base64 __hx_this)
	{
	}
	
	
	public static java.lang.String CHARS;
	
	public static haxe.io.Bytes BYTES;
	
	public static java.lang.String URL_CHARS;
	
	public static haxe.io.Bytes URL_BYTES;
	
	public static java.lang.String encode(haxe.io.Bytes bytes, java.lang.Object complement)
	{
		//line 35 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		boolean complement1 = ( (haxe.lang.Runtime.eq(complement, null)) ? (true) : (haxe.lang.Runtime.toBool(((java.lang.Boolean) (complement) ))) );
		//line 36 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		java.lang.String str = new haxe.crypto.BaseCode(((haxe.io.Bytes) (haxe.crypto.Base64.BYTES) )).encodeBytes(bytes).toString();
		//line 37 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		if (complement1) 
		{
			//line 38 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
			switch (( bytes.length % 3 ))
			{
				case 1:
				{
					//line 40 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
					str += "==";
					//line 40 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
					break;
				}
				
				
				case 2:
				{
					//line 42 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
					str += "=";
					//line 42 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
					break;
				}
				
				
				default:
				{
					//line 43 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
					break;
				}
				
			}
			
		}
		
		//line 45 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		return str;
	}
	
	
	public static haxe.io.Bytes decode(java.lang.String str, java.lang.Object complement)
	{
		//line 48 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		boolean complement1 = ( (haxe.lang.Runtime.eq(complement, null)) ? (true) : (haxe.lang.Runtime.toBool(((java.lang.Boolean) (complement) ))) );
		//line 49 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		if (complement1) 
		{
			//line 50 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
			while (haxe.lang.Runtime.eq(haxe.lang.StringExt.charCodeAt(str, ( str.length() - 1 )), 61))
			{
				//line 51 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
				str = haxe.lang.StringExt.substr(str, 0, -1);
			}
			
		}
		
		//line 52 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		return new haxe.crypto.BaseCode(((haxe.io.Bytes) (haxe.crypto.Base64.BYTES) )).decodeBytes(haxe.io.Bytes.ofString(str, null));
	}
	
	
	public static java.lang.String urlEncode(haxe.io.Bytes bytes, java.lang.Object complement)
	{
		//line 55 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		boolean complement1 = ( (haxe.lang.Runtime.eq(complement, null)) ? (false) : (haxe.lang.Runtime.toBool(((java.lang.Boolean) (complement) ))) );
		//line 56 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		java.lang.String str = new haxe.crypto.BaseCode(((haxe.io.Bytes) (haxe.crypto.Base64.URL_BYTES) )).encodeBytes(bytes).toString();
		//line 57 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		if (complement1) 
		{
			//line 58 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
			switch (( bytes.length % 3 ))
			{
				case 1:
				{
					//line 60 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
					str += "==";
					//line 60 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
					break;
				}
				
				
				case 2:
				{
					//line 62 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
					str += "=";
					//line 62 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
					break;
				}
				
				
				default:
				{
					//line 63 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
					break;
				}
				
			}
			
		}
		
		//line 65 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		return str;
	}
	
	
	public static haxe.io.Bytes urlDecode(java.lang.String str, java.lang.Object complement)
	{
		//line 68 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		boolean complement1 = ( (haxe.lang.Runtime.eq(complement, null)) ? (false) : (haxe.lang.Runtime.toBool(((java.lang.Boolean) (complement) ))) );
		//line 69 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		if (complement1) 
		{
			//line 70 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
			while (haxe.lang.Runtime.eq(haxe.lang.StringExt.charCodeAt(str, ( str.length() - 1 )), 61))
			{
				//line 71 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
				str = haxe.lang.StringExt.substr(str, 0, -1);
			}
			
		}
		
		//line 72 "/home/travis/haxe/std/haxe/crypto/Base64.hx"
		return new haxe.crypto.BaseCode(((haxe.io.Bytes) (haxe.crypto.Base64.URL_BYTES) )).decodeBytes(haxe.io.Bytes.ofString(str, null));
	}
	
	
}


